Ytrainfull = select(Xtrainfull, YtrainRelevel) %>% unlist() %>% as.vector()
Ytrainfull = to_categorical(Ytrainfull)
#Xtest
Xtestfull = cbind(YtestRelevel,XtestMat) %>% as.data.frame()
XtestfullMat = select(Xtestfull, -YtestRelevel) %>% as.matrix()
dimnames(XtestfullMat) = NULL
#Ytest
Ytestfull = select(Xtestfull, YtestRelevel) %>% unlist() %>% as.vector()
Ytestfull = to_categorical(Ytestfull)
set.seed(123)
model = keras_model_sequential() %>%
layer_dense(units = 400, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 4, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 2, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 3, activation="sigmoid")
model
model = model %>% compile(optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "BinaryAccuracy")
callbacks_list = list(callback_early_stopping(monitor = "val_loss", patience = 15))
my_model = model %>% fit(XtrainfullMat, Ytrainfull, epoch=50, batch_size=40, validation_data=list(XtestfullMat, Ytestfull))
#adjusting data types
#Xtrain
Xtrainfull = cbind(YtrainRelevel,XtrainMat) %>% as.data.frame()
XtrainfullMat = select(Xtrainfull, -YtrainRelevel) %>% as.matrix()
dimnames(XtrainfullMat) = NULL
#Ytrain
Ytrainfull = select(Xtrainfull, YtrainRelevel) %>% unlist() %>% as.vector()
Ytrainfull = to_categorical(Ytrainfull)
#Xtest
Xtestfull = cbind(YtestRelevel,XtestMat) %>% as.data.frame()
XtestfullMat = select(Xtestfull, -YtestRelevel) %>% as.matrix()
dimnames(XtestfullMat) = NULL
#Ytest
Ytestfull = select(Xtestfull, YtestRelevel) %>% unlist() %>% as.vector()
Ytestfull = to_categorical(Ytestfull)
set.seed(123)
model = keras_model_sequential() %>%
layer_dense(units = 400, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 200, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 100, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 4, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 2, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 3, activation="sigmoid")
model
model = model %>% compile(optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "BinaryAccuracy")
callbacks_list = list(callback_early_stopping(monitor = "val_loss", patience = 15))
my_model = model %>% fit(XtrainfullMat, Ytrainfull, epoch=50, batch_size=25, validation_data=list(XtestfullMat, Ytestfull))
model %>% evaluate(XtestfullMat, Ytestfull)
#confusion Matrix
prob = model %>% predict(XtestfullMat) %>% k_argmax() %>% as.numeric()
Ytestfull = Ytestfull %>% k_argmax() %>% as.numeric()
prob = as.factor(prob) %>% recode("1" = "Default", "2" = "paid")
Ytestfull2 = as.factor(Ytestfull) %>% recode("1" = "Default","2" = "paid")
confusionMatrixOutNN = confusionMatrix(reference = Ytestfull2, data = prob)
confusionMatrixOutNN$table
print(confusionMatrixOutNN$overall[1:2])
print(confusionMatrixOutNN$byClass[1:2])
#adjusting data types
#Xtrain
Xtrainfull = cbind(YtrainRelevel,XtrainMat) %>% as.data.frame()
XtrainfullMat = select(Xtrainfull, -YtrainRelevel) %>% as.matrix()
dimnames(XtrainfullMat) = NULL
#Ytrain
Ytrainfull = select(Xtrainfull, YtrainRelevel) %>% unlist() %>% as.vector()
Ytrainfull = to_categorical(Ytrainfull)
#Xtest
Xtestfull = cbind(YtestRelevel,XtestMat) %>% as.data.frame()
XtestfullMat = select(Xtestfull, -YtestRelevel) %>% as.matrix()
dimnames(XtestfullMat) = NULL
#Ytest
Ytestfull = select(Xtestfull, YtestRelevel) %>% unlist() %>% as.vector()
Ytestfull = to_categorical(Ytestfull)
set.seed(123)
model = keras_model_sequential() %>%
layer_dense(units = 512, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 256, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 128, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.1) %>%
layer_dense(units = 64, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.1) %>%
layer_dense(units = 8, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 4, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 2, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 3, activation="sigmoid")
model
model = model %>% compile(optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "BinaryAccuracy")
callbacks_list = list(callback_early_stopping(monitor = "val_loss", patience = 15))
my_model = model %>% fit(XtrainfullMat, Ytrainfull, epoch=50, batch_size=25, validation_data=list(XtestfullMat, Ytestfull))
#adjusting data types
#Xtrain
Xtrainfull = cbind(YtrainRelevel,XtrainMat) %>% as.data.frame()
XtrainfullMat = select(Xtrainfull, -YtrainRelevel) %>% as.matrix()
dimnames(XtrainfullMat) = NULL
#Ytrain
Ytrainfull = select(Xtrainfull, YtrainRelevel) %>% unlist() %>% as.vector()
Ytrainfull = to_categorical(Ytrainfull)
#Xtest
Xtestfull = cbind(YtestRelevel,XtestMat) %>% as.data.frame()
XtestfullMat = select(Xtestfull, -YtestRelevel) %>% as.matrix()
dimnames(XtestfullMat) = NULL
#Ytest
Ytestfull = select(Xtestfull, YtestRelevel) %>% unlist() %>% as.vector()
Ytestfull = to_categorical(Ytestfull)
set.seed(123)
model = keras_model_sequential() %>%
layer_dense(units = 512, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 256, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 128, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 64, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 4, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 2, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 3, activation="sigmoid")
model
model = model %>% compile(optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "BinaryAccuracy")
callbacks_list = list(callback_early_stopping(monitor = "val_loss", patience = 15))
my_model = model %>% fit(XtrainfullMat, Ytrainfull, epoch=50, batch_size=25, validation_data=list(XtestfullMat, Ytestfull))
model %>% evaluate(XtestfullMat, Ytestfull)
#confusion Matrix
prob = model %>% predict(XtestfullMat) %>% k_argmax() %>% as.numeric()
Ytestfull = Ytestfull %>% k_argmax() %>% as.numeric()
prob = as.factor(prob) %>% recode("1" = "Default", "2" = "paid")
Ytestfull2 = as.factor(Ytestfull) %>% recode("1" = "Default","2" = "paid")
confusionMatrixOutNN = confusionMatrix(reference = Ytestfull2, data = prob)
confusionMatrixOutNN$table
print(confusionMatrixOutNN$overall[1:2])
print(confusionMatrixOutNN$byClass[1:2])
my_model
#adjusting data types
#Xtrain
Xtrainfull = cbind(YtrainRelevel,XtrainMat) %>% as.data.frame()
XtrainfullMat = select(Xtrainfull, -YtrainRelevel) %>% as.matrix()
dimnames(XtrainfullMat) = NULL
#Ytrain
Ytrainfull = select(Xtrainfull, YtrainRelevel) %>% unlist() %>% as.vector()
Ytrainfull = to_categorical(Ytrainfull)
#Xtest
Xtestfull = cbind(YtestRelevel,XtestMat) %>% as.data.frame()
XtestfullMat = select(Xtestfull, -YtestRelevel) %>% as.matrix()
dimnames(XtestfullMat) = NULL
#Ytest
Ytestfull = select(Xtestfull, YtestRelevel) %>% unlist() %>% as.vector()
Ytestfull = to_categorical(Ytestfull)
set.seed(123)
n=3
models = for (i in range(n)){
model = keras_model_sequential() %>%
layer_dense(units = 256, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 128, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 64, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 4, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 2, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 3, activation="sigmoid")
model
model = model %>% compile(optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "BinaryAccuracy")
callbacks_list = list(callback_early_stopping(monitor = "val_loss", patience = 15))
my_model = model %>% fit(XtrainfullMat, Ytrainfull, epoch=50, batch_size=25, validation_data=list(XtestfullMat, Ytestfull))
}
outcome = mean(models)
model %>% evaluate(XtestfullMat, Ytestfull)
#confusion Matrix
prob = model %>% predict(XtestfullMat) %>% k_argmax() %>% as.numeric()
Ytestfull = Ytestfull %>% k_argmax() %>% as.numeric()
prob = as.factor(prob) %>% recode("1" = "Default", "2" = "paid")
Ytestfull2 = as.factor(Ytestfull) %>% recode("1" = "Default","2" = "paid")
confusionMatrixOutNN = confusionMatrix(reference = Ytestfull2, data = prob)
confusionMatrixOutNN$table
print(confusionMatrixOutNN$overall[1:2])
print(confusionMatrixOutNN$byClass[1:2])
models
outcome = mean(models)
models
#adjusting data types
#Xtrain
Xtrainfull = cbind(YtrainRelevel,XtrainMat) %>% as.data.frame()
XtrainfullMat = select(Xtrainfull, -YtrainRelevel) %>% as.matrix()
dimnames(XtrainfullMat) = NULL
#Ytrain
Ytrainfull = select(Xtrainfull, YtrainRelevel) %>% unlist() %>% as.vector()
Ytrainfull = to_categorical(Ytrainfull)
#Xtest
Xtestfull = cbind(YtestRelevel,XtestMat) %>% as.data.frame()
XtestfullMat = select(Xtestfull, -YtestRelevel) %>% as.matrix()
dimnames(XtestfullMat) = NULL
#Ytest
Ytestfull = select(Xtestfull, YtestRelevel) %>% unlist() %>% as.vector()
Ytestfull = to_categorical(Ytestfull)
set.seed(123)
model = keras_model_sequential() %>%
layer_dense(units = 256, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 128, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 64, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dropout(rate = 0.5) %>%
layer_dense(units = 8, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 4, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 2, activation = "relu",
input_shape = dim(XtrainfullMat)[[2]]) %>%
layer_dense(units = 3, activation="sigmoid")
model
model = model %>% compile(optimizer = "rmsprop",
loss = "binary_crossentropy",
metrics = "BinaryAccuracy")
callbacks_list = list(callback_early_stopping(monitor = "val_loss", patience = 15))
my_model = model %>% fit(XtrainfullMat, Ytrainfull, epoch=50, batch_size=25, validation_data=list(XtestfullMat, Ytestfull))
model %>% evaluate(XtestfullMat, Ytestfull)
#confusion Matrix
prob = model %>% predict(XtestfullMat) %>% k_argmax() %>% as.numeric()
Ytestfull = Ytestfull %>% k_argmax() %>% as.numeric()
prob = as.factor(prob) %>% recode("1" = "Default", "2" = "paid")
Ytestfull2 = as.factor(Ytestfull) %>% recode("1" = "Default","2" = "paid")
confusionMatrixOutNN = confusionMatrix(reference = Ytestfull2, data = prob)
confusionMatrixOutNN$table
print(confusionMatrixOutNN$overall[1:2])
print(confusionMatrixOutNN$byClass[1:2])
table(prob, Ytestfull)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
rocCurveRF$auc
set.seed(123)
tuneGridRanger = data.frame(splitrule = 'gini',min.node.size = c(15,20,25,35),
mtry = round(sqrt(ncol(XtrainMat))))
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 300,
tuneGrid = tuneGridRanger,
metric = 'Accuracy',
trControl = trainControl(method = "cv", number = 3,classProbs=TRUE))
plot(rfOut)
rfOut$bestTune
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
rocCurveRF = roc(YtestT, YhattestRF$`Default`)
plot(rocCurveRF, legacy.axes=TRUE)
rocCurveRF$auc
#confusion matrix
YhattestRF = predict(rfOut, XtestMat)
confusionMatrixOutRF = confusionMatrix(reference = YtestT, data = YhattestRF)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
set.seed(123)
tuneGridRanger = data.frame(splitrule = 'gini',min.node.size = c(15,20,25,35),
mtry = round(sqrt(ncol(XtrainMat))))
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 500,
tuneGrid = tuneGridRanger,
metric = 'Accuracy',
trControl = trainControl(method = "cv", number = 3,classProbs=TRUE))
plot(rfOut)
rfOut$bestTune
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
rocCurveRF = roc(YtestT, YhattestRF$`Default`)
plot(rocCurveRF, legacy.axes=TRUE)
rocCurveRF$auc
#confusion matrix
YhattestRF = predict(rfOut, XtestMat)
confusionMatrixOutRF = confusionMatrix(reference = YtestT, data = YhattestRF)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
set.seed(123)
tuneGridRanger = data.frame(splitrule = 'gini',min.node.size = c(15,20,25,35),
mtry = round(sqrt(ncol(XtrainMat))))
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 1000,
tuneGrid = tuneGridRanger,
metric = 'Accuracy',
trControl = trainControl(method = "cv", number = 2,classProbs=TRUE))
plot(rfOut)
rfOut$bestTune
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
rocCurveRF = roc(YtestT, YhattestRF$`Default`)
plot(rocCurveRF, legacy.axes=TRUE)
rocCurveRF$auc
#confusion matrix
YhattestRF = predict(rfOut, XtestMat)
confusionMatrixOutRF = confusionMatrix(reference = YtestT, data = YhattestRF)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
set.seed(123)
tuneGridRanger = data.frame(splitrule = 'gini',min.node.size = c(15,20,25,35),
mtry = round(sqrt(ncol(XtrainMat))))
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 150,
tuneGrid = tuneGridRanger,
metric = 'Accuracy',
trControl = trainControl(method = "cv", number = 5,classProbs=TRUE))
plot(rfOut)
rfOut$bestTune
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 2000,
tuneGrid = rfOut$bestTune,
metric = 'Accuracy',
trControl = trainControl(method = 'none'))
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
predict(rfOut, XtestMat, type='prob')
rfOut
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 2000,
tuneGrid = rfOut$bestTune,
metric = 'Accuracy',
trControl = trainControl(method = 'none', classProbs=TRUE))
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
rocCurveRF = roc(YtestT, YhattestRF$`Default`)
plot(rocCurveRF, legacy.axes=TRUE)
rocCurveRF$auc
#confusion matrix
YhattestRF = predict(rfOut, XtestMat)
confusionMatrixOutRF = confusionMatrix(reference = YtestT, data = YhattestRF)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 5000,
tuneGrid = rfOut$bestTune,
metric = 'Accuracy',
trControl = trainControl(method = 'none', classProbs=TRUE))
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
rocCurveRF = roc(YtestT, YhattestRF$`Default`)
plot(rocCurveRF, legacy.axes=TRUE)
rocCurveRF$auc
#confusion matrix
YhattestRF = predict(rfOut, XtestMat)
confusionMatrixOutRF = confusionMatrix(reference = YtestT, data = YhattestRF)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 1000,
tuneGrid = rfOut$bestTune,
metric = 'Accuracy',
trControl = trainControl(method = 'none', classProbs=TRUE))
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
rocCurveRF = roc(YtestT, YhattestRF$`Default`)
plot(rocCurveRF, legacy.axes=TRUE)
rocCurveRF$auc
#confusion matrix
YhattestRF = predict(rfOut, XtestMat)
confusionMatrixOutRF = confusionMatrix(reference = YtestT, data = YhattestRF)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
rocCurveRF$auc
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 500,
tuneGrid = rfOut$bestTune,
metric = 'Accuracy',
trControl = trainControl(method = 'none', classProbs=TRUE))
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
rocCurveRF = roc(YtestT, YhattestRF$`Default`)
plot(rocCurveRF, legacy.axes=TRUE)
rocCurveRF$auc
#confusion matrix
YhattestRF = predict(rfOut, XtestMat)
confusionMatrixOutRF = confusionMatrix(reference = YtestT, data = YhattestRF)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 200,
tuneGrid = rfOut$bestTune,
metric = 'Accuracy',
trControl = trainControl(method = 'none', classProbs=TRUE))
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
rocCurveRF = roc(YtestT, YhattestRF$`Default`)
plot(rocCurveRF, legacy.axes=TRUE)
rocCurveRF$auc
#confusion matrix
YhattestRF = predict(rfOut, XtestMat)
confusionMatrixOutRF = confusionMatrix(reference = YtestT, data = YhattestRF)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 100,
tuneGrid = rfOut$bestTune,
metric = 'Accuracy',
trControl = trainControl(method = 'none', classProbs=TRUE))
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
rocCurveRF = roc(YtestT, YhattestRF$`Default`)
plot(rocCurveRF, legacy.axes=TRUE)
rocCurveRF$auc
#confusion matrix
YhattestRF = predict(rfOut, XtestMat)
confusionMatrixOutRF = confusionMatrix(reference = YtestT, data = YhattestRF)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 50,
tuneGrid = rfOut$bestTune,
metric = 'Accuracy',
trControl = trainControl(method = 'none', classProbs=TRUE))
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
rocCurveRF = roc(YtestT, YhattestRF$`Default`)
plot(rocCurveRF, legacy.axes=TRUE)
rocCurveRF$auc
#confusion matrix
YhattestRF = predict(rfOut, XtestMat)
confusionMatrixOutRF = confusionMatrix(reference = YtestT, data = YhattestRF)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
rfOut = train(x = XtrainMat, y = YtrainT,
method = "ranger",
num.trees = 200,
tuneGrid = rfOut$bestTune,
metric = 'Accuracy',
trControl = trainControl(method = 'none', classProbs=TRUE))
#ROC curve
YhattestRF = predict(rfOut, XtestMat, type='prob')
rocCurveRF = roc(YtestT, YhattestRF$`Default`)
plot(rocCurveRF, legacy.axes=TRUE)
rocCurveRF$auc
#confusion matrix
YhattestRF = predict(rfOut, XtestMat)
confusionMatrixOutRF = confusionMatrix(reference = YtestT, data = YhattestRF)
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
confusionMatrixOutRF$table
print(confusionMatrixOutRF$overall[1:2])
print(confusionMatrixOutRF$byClass[1:2])
rocCurveRF$auc
