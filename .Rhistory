data$earliest_cr_line = sub(".*-", "", data$earliest_cr_line) %>% as.numeric(.)
current = 8 - data$earliest_cr_line[data$earliest_cr_line < 20]
old = data$earliest_cr_line[data$earliest_cr_line > 20] %>% as.character(.)
old = paste("19",old)
old = sub(" ","", old) %>% as.numeric(.)
old = 2008 - old
current = as.character(current)
old = as.character(old)
data$earliest_cr_line = as.numeric(c(current, old))
table(current)
table(old)
as.numeric(c(current, old))
data$earliest_cr_line = as.numeric(c(current, old))
table(data$earliest_cr_line)
```{r data, include=F}
data = read_csv("Data/LoanStats3a.csv")
# Overview
Here we filtered the loan_status column to keep only the rows where the loan was either in default/charged off or was fully paid.
```{r echo=F}
#Transform loan status
data$loan_status[data$loan_status == "Charged Off"] = "Default"
data$loan_status[data$loan_status == "Does not meet the credit policy. Status:Charged Off"] = "Default"
data= data %>% filter(loan_status == "Default" | loan_status == "Fully Paid")
unique(data$loan_status)
data%>%select(loan_status)%>%group_by(loan_status)%>%count(.)
```
# Exploratory Analysis
## Missing Values
The goal of this section is to identify features that are eligible for feature wise deletion in order to make the data set easier to navigate. Part II discusses how to handle any remaining missing values. The original dataset contains 39719 observations and 111 variables.
```{r include=F}
anyNA(data) # to see if there are any missing values in the dataset
dim(data) # number of observations and features
```
```{r echo=F, warning=F, message=F, error=F}
ggplot_missing <- function(x){
if(!require(reshape2)){warning('you need to install reshape2')}
require(reshape2)
require(ggplot2)
#### This function produces a plot of the missing data pattern
#### in x. It is a modified version of a function in the 'neato' package
x %>%
is.na %>%
melt %>%
ggplot(data = .,
aes(x = Var2,
y = Var1)) +
geom_raster(aes(fill = value)) +
scale_fill_grey(name = "",
labels = c("Present","Missing")) +
theme_minimal() +
theme(axis.text.x = element_text(angle=45, vjust=0.5)) +
labs(x = "Variables in Dataset",
y = "Rows / observations")
}
```
```{r echo=F}
ggplot_missing(data) # visualize missing data
```
The missingness plot indicates that a large amount of features have a high percentage of missing values. The following output shows the exact percentages per feature.
```{r echo=F}
round(colMeans(is.na(data))*100,3)
```
Thus, it makes sense to delete features with a large percentage of missing values. The general rule of thumb is to delete any features with 33% or more.
```{r include=F}
data = data %>% select_if(~mean(is.na(.))<=0.33) # drop features with a lot of NAs
dim(data) # dimensions of altered dataset
```
After dropping the features that fall into this category, 54 variables remain in the dataset.  Before using any kind of imputation method the data is split into a training and test set. Imputation is only performed on the features of the training set. Mode imputation is used for qualitative features, and imputation using median values or linear methods are used for quantitative features.
## Data structures
The following section of code explores the data structures in order to identify any qualitative features that might be coded as quantitative features and vice versa. First, the number of features per data type is displayed.
```{r echo=F}
table(sapply(data[1,],class)) # number of features per data type
```
To get a closer look at the data types for each feature, the following output can be used.
```{r echo=F}
str(data) # overview of data types
```
Furthermore, the number of unique values per features are displayed.
```{r echo=F}
sapply(data,function(x){ length(unique(x))})
```
There are some qualitative features, some coded as character and some as numeric, that need to be converted to factors. In addition, it seems like some features only have one value (besides NA) and should therefore be dropped. We also found that we will likely be unable to extract any useful information from some features. We also tried to keep only the features that were available to an investor before they invested on the loan. After making some transformations, the dataset looks as follows.
```{r echo=F}
# features with only one value that will be dropped:
#     collections_12_mths_ex_med,
#     application_type,
#     policy_code,
#     chargeoff_within_12_mths
#     init_list_status
#     acc_now_delinq
#     delinq_amnt
data = data %>% select(-c(collections_12_mths_ex_med,
application_type,
policy_code,
chargeoff_within_12_mths,
initial_list_status,
acc_now_delinq,
delinq_amnt,
tax_liens))
# These features are uninformative and will be dropped:
# We may need to state why they are uninformative.
# zip_code
# id
# member_id
# emp_title
# title
# url
# desc
data = data %>% select(-c(zip_code,
id,
member_id,
emp_title,
title,
url,
desc))
# Keep only the features that are available to us before someone invested on the loan.
# Features that were not available before loan disbursement:
# total_pymnt
# total_pymnt_inv
# total_rec_prncp,
# total_rec_int,
# total_rec_late_fee,
# recoveries,
# collection_recovery_fee,
# last_pymnt_d,
# last_pymnt_amnt,
data = data %>% select(-c(total_pymnt,
total_pymnt_inv,
total_rec_prncp,
total_rec_int,
total_rec_late_fee,
recoveries,
collection_recovery_fee,
last_pymnt_amnt))
##### Dates converted to factors for now
# Are you guys cool with converting some of these dates to numeric values where we can? # I think they could be a little more useful this way instead of just leaving them out of the model or converting them all as factors.
#issue_d: date
#last_pymnt_d: date
#last_credit_pull_d: date
#earliest_cr_line: date
# Converting employment length to number of years they have been employed.
data$emp_length[which(data$emp_length == "10+ years")] = 10
data$emp_length[which(data$emp_length == "< 1 year")] = 0
data$emp_length[which(data$emp_length == "n/a")] = NA
data$emp_length = sub(" years", "", data$emp_length)
data$emp_length = sub(" year", "", data$emp_length)
data$emp_length = as.numeric(data$emp_length)
#Converted issue_d to the month that the loan was issued
data$issue_d = sub("-.*", "", data$issue_d) %>% as.factor(.)
table(data$earliest_cr_line)
data$earliest_cr_line = sub("-[[:alpha:]]+","", data$earliest_cr_line)
table(data$earliest_cr_line)
sub(".*-", "", data$earliest_cr_line) %>% as.numeric(.)
data$earliest_cr_line = sub(".*-", "", data$earliest_cr_line) %>% as.numeric(.)
8 - data$earliest_cr_line[data$earliest_cr_line < 20]
8 - data$earliest_cr_line[data$earliest_cr_line < 10]
current = 8 - data$earliest_cr_line[data$earliest_cr_line < 9]
old = data$earliest_cr_line[data$earliest_cr_line > 9] %>% as.character(.)
paste("19",old)
old = paste("19",old)
old = sub(" ","", old) %>% as.numeric(.)
2008 - old
old = 2008 - old
current = as.character(current)
old = as.character(old)
table(current)
as.numeric(c(current, old))
data = read_csv("Data/LoanStats3a.csv")
# Overview
Here we filtered the loan_status column to keep only the rows where the loan was either in default/charged off or was fully paid.
```{r echo=F}
#Transform loan status
data$loan_status[data$loan_status == "Charged Off"] = "Default"
data$loan_status[data$loan_status == "Does not meet the credit policy. Status:Charged Off"] = "Default"
data= data %>% filter(loan_status == "Default" | loan_status == "Fully Paid")
unique(data$loan_status)
data%>%select(loan_status)%>%group_by(loan_status)%>%count(.)
```
# Exploratory Analysis
## Missing Values
The goal of this section is to identify features that are eligible for feature wise deletion in order to make the data set easier to navigate. Part II discusses how to handle any remaining missing values. The original dataset contains 39719 observations and 111 variables.
```{r include=F}
anyNA(data) # to see if there are any missing values in the dataset
dim(data) # number of observations and features
```
```{r echo=F, warning=F, message=F, error=F}
ggplot_missing <- function(x){
if(!require(reshape2)){warning('you need to install reshape2')}
require(reshape2)
require(ggplot2)
#### This function produces a plot of the missing data pattern
#### in x. It is a modified version of a function in the 'neato' package
x %>%
is.na %>%
melt %>%
ggplot(data = .,
aes(x = Var2,
y = Var1)) +
geom_raster(aes(fill = value)) +
scale_fill_grey(name = "",
labels = c("Present","Missing")) +
theme_minimal() +
theme(axis.text.x = element_text(angle=45, vjust=0.5)) +
labs(x = "Variables in Dataset",
y = "Rows / observations")
}
```
```{r echo=F}
ggplot_missing(data) # visualize missing data
```
The missingness plot indicates that a large amount of features have a high percentage of missing values. The following output shows the exact percentages per feature.
```{r echo=F}
round(colMeans(is.na(data))*100,3)
```
Thus, it makes sense to delete features with a large percentage of missing values. The general rule of thumb is to delete any features with 33% or more.
```{r include=F}
data = data %>% select_if(~mean(is.na(.))<=0.33) # drop features with a lot of NAs
dim(data) # dimensions of altered dataset
```
After dropping the features that fall into this category, 54 variables remain in the dataset.  Before using any kind of imputation method the data is split into a training and test set. Imputation is only performed on the features of the training set. Mode imputation is used for qualitative features, and imputation using median values or linear methods are used for quantitative features.
## Data structures
The following section of code explores the data structures in order to identify any qualitative features that might be coded as quantitative features and vice versa. First, the number of features per data type is displayed.
```{r echo=F}
table(sapply(data[1,],class)) # number of features per data type
```
To get a closer look at the data types for each feature, the following output can be used.
```{r echo=F}
str(data) # overview of data types
```
Furthermore, the number of unique values per features are displayed.
```{r echo=F}
sapply(data,function(x){ length(unique(x))})
```
There are some qualitative features, some coded as character and some as numeric, that need to be converted to factors. In addition, it seems like some features only have one value (besides NA) and should therefore be dropped. We also found that we will likely be unable to extract any useful information from some features. We also tried to keep only the features that were available to an investor before they invested on the loan. After making some transformations, the dataset looks as follows.
```{r echo=F}
# features with only one value that will be dropped:
#     collections_12_mths_ex_med,
#     application_type,
#     policy_code,
#     chargeoff_within_12_mths
#     init_list_status
#     acc_now_delinq
#     delinq_amnt
data = data %>% select(-c(collections_12_mths_ex_med,
application_type,
policy_code,
chargeoff_within_12_mths,
initial_list_status,
acc_now_delinq,
delinq_amnt,
tax_liens))
# These features are uninformative and will be dropped:
# We may need to state why they are uninformative.
# zip_code
# id
# member_id
# emp_title
# title
# url
# desc
data = data %>% select(-c(zip_code,
id,
member_id,
emp_title,
title,
url,
desc))
# Keep only the features that are available to us before someone invested on the loan.
# Features that were not available before loan disbursement:
# total_pymnt
# total_pymnt_inv
# total_rec_prncp,
# total_rec_int,
# total_rec_late_fee,
# recoveries,
# collection_recovery_fee,
# last_pymnt_d,
# last_pymnt_amnt,
data = data %>% select(-c(total_pymnt,
total_pymnt_inv,
total_rec_prncp,
total_rec_int,
total_rec_late_fee,
recoveries,
collection_recovery_fee,
last_pymnt_amnt))
##### Dates converted to factors for now
# Are you guys cool with converting some of these dates to numeric values where we can? # I think they could be a little more useful this way instead of just leaving them out of the model or converting them all as factors.
#issue_d: date
#last_pymnt_d: date
#last_credit_pull_d: date
#earliest_cr_line: date
# Converting employment length to number of years they have been employed.
data$emp_length[which(data$emp_length == "10+ years")] = 10
data$emp_length[which(data$emp_length == "< 1 year")] = 0
data$emp_length[which(data$emp_length == "n/a")] = NA
data$emp_length = sub(" years", "", data$emp_length)
data$emp_length = sub(" year", "", data$emp_length)
data$emp_length = as.numeric(data$emp_length)
#Converted issue_d to the month that the loan was issued
data$issue_d = sub("-.*", "", data$issue_d) %>% as.factor(.)
data$earliest_cr_line = sub("-[[:alpha:]]+","", data$earliest_cr_line)
data$earliest_cr_line = sub(".*-", "", data$earliest_cr_line) %>% as.numeric(.)
nrow(data$earliest_cr_line)
length(data$earliest_cr_line)
length(8 - data$earliest_cr_line[data$earliest_cr_line < 9])
length(data$earliest_cr_line[data$earliest_cr_line > 9] %>% as.character(.))
length(data$earliest_cr_line[data$earliest_cr_line > 10] %>% as.character(.))
table(data$earliest_cr_line[data$earliest_cr_line < 9)
table(data$earliest_cr_line[data$earliest_cr_line < 9])
table(data$earliest_cr_line[data$earliest_cr_line > 9])
length(data$earliest_cr_line[data$earliest_cr_line > 9])
length(data$earliest_cr_line[data$earliest_cr_line < 9])
length(data$earliest_cr_line[data$earliest_cr_line <= 8])
length(data$earliest_cr_line[data$earliest_cr_line >= 8])
length(data$earliest_cr_line[data$earliest_cr_line > 8])
str(data$earliest_cr_line[data$earliest_cr_line <= 8])
str(data$earliest_cr_line[data$earliest_cr_line > 8])
table(data$earliest_cr_line)
str(data$earliest_cr_line)
length(data$earliest_cr_line[data$earliest_cr_line <= 8])+length(data$earliest_cr_line[data$earliest_cr_line > 8])
anyNA(data$earliest_cr_line)
sapply(data, function(x) sum(is.na(data))
l
sapply(data, function(x) sum(is.na(x))
l
sapply(data, function(x) sum(is.na(x)))
(8 - data$earliest_cr_line[data$earliest_cr_line <= 8],na.rm=TRUE)
!is.na(data$earliest_cr_line[data$earliest_cr_line <= 8])
complete.cases(data$earliest_cr_line[data$earliest_cr_line <= 8])
na.omit(data$earliest_cr_line[data$earliest_cr_line <= 8])
current = 8 - na.omit(data$earliest_cr_line[data$earliest_cr_line <= 8])
old = data$earliest_cr_line[data$earliest_cr_line > 8] %>% as.character(.)
old = paste("19",old)
old = sub(" ","", old) %>% as.numeric(.)
old = 2008 - old
current = as.character(current)
old = as.character(old)
table(current)
table(old)
data$earliest_cr_line = as.numeric(c(current, old))
length(data$earliest_cr_line)
table(data$earliest_cr_line)
#This converts last_credit_pull_d to the month of their last credit pull.
data$last_credit_pull_d = sub("-.*", "", data$last_credit_pull_d) %>% as.factor(.)
#Gets rid of the percent signs for revol_util and int_rate and converts them to numeric
data$revol_util = as.numeric(sub("%","",data$revol_util))
data$int_rate = as.numeric(sub("%","",data$int_rate))
str(data)
table(data$last_pymnt_d)
data = read_csv("Data/LoanStats3a.csv")
#Transform loan status
data$loan_status[data$loan_status == "Charged Off"] = "Default"
data$loan_status[data$loan_status == "Does not meet the credit policy. Status:Charged Off"] = "Default"
data= data %>% filter(loan_status == "Default" | loan_status == "Fully Paid")
unique(data$loan_status)
data%>%select(loan_status)%>%group_by(loan_status)%>%count(.)
anyNA(data) # to see if there are any missing values in the dataset
dim(data) # number of observations and features
ggplot_missing <- function(x){
if(!require(reshape2)){warning('you need to install reshape2')}
require(reshape2)
require(ggplot2)
#### This function produces a plot of the missing data pattern
#### in x. It is a modified version of a function in the 'neato' package
x %>%
is.na %>%
melt %>%
ggplot(data = .,
aes(x = Var2,
y = Var1)) +
geom_raster(aes(fill = value)) +
scale_fill_grey(name = "",
labels = c("Present","Missing")) +
theme_minimal() +
theme(axis.text.x = element_text(angle=45, vjust=0.5)) +
labs(x = "Variables in Dataset",
y = "Rows / observations")
}
round(colMeans(is.na(data))*100,3)
data = data %>% select_if(~mean(is.na(.))<=0.33) # drop features with a lot of NAs
dim(data) # dimensions of altered dataset
table(sapply(data[1,],class)) # number of features per data type
str(data) # overview of data types
sapply(data,function(x){ length(unique(x))})
# features with only one value that will be dropped:
#     collections_12_mths_ex_med,
#     application_type,
#     policy_code,
#     chargeoff_within_12_mths
#     init_list_status
#     acc_now_delinq
#     delinq_amnt
data = data %>% select(-c(collections_12_mths_ex_med,
application_type,
policy_code,
chargeoff_within_12_mths,
initial_list_status,
acc_now_delinq,
delinq_amnt,
tax_liens))
# These features are uninformative and will be dropped:
# We may need to state why they are uninformative.
# zip_code
# id
# member_id
# emp_title
# title
# url
# desc
data = data %>% select(-c(zip_code,
id,
member_id,
emp_title,
title,
url,
desc))
# total_pymnt
# total_pymnt_inv
# total_rec_prncp,
# total_rec_int,
# total_rec_late_fee,
# recoveries,
# collection_recovery_fee,
# last_pymnt_d,
# last_pymnt_amnt,
data = data %>% select(-c(total_pymnt,
total_pymnt_inv,
total_rec_prncp,
total_rec_int,
total_rec_late_fee,
recoveries,
collection_recovery_fee,
last_pymnt_d,
last_pymnt_amnt))
##### Dates converted to factors for now
# Are you guys cool with converting some of these dates to numeric values where we can? # I think they could be a little more useful this way instead of just leaving them out of the model or converting them all as factors.
#issue_d: date
#last_credit_pull_d: date
#earliest_cr_line: date
# Converting employment length to number of years they have been employed.
data$emp_length[which(data$emp_length == "10+ years")] = 10
data$emp_length[which(data$emp_length == "< 1 year")] = 0
data$emp_length[which(data$emp_length == "n/a")] = NA
data$emp_length = sub(" years", "", data$emp_length)
data$emp_length = sub(" year", "", data$emp_length)
data$emp_length = as.numeric(data$emp_length)
#Converted issue_d to the month that the loan was issued
data$issue_d = sub("-.*", "", data$issue_d)
#This code will convert earliest_cr_line to the number of years since their earliest credit line. Also, I think this was last updated in 2008 since the earliest credit line for someone was in 2008.
table(data$earliest_cr_line)
data$earliest_cr_line = sub("-[[:alpha:]]+","", data$earliest_cr_line)
data$earliest_cr_line = sub(".*-", "", data$earliest_cr_line) %>% as.numeric(.)
current = 8 - na.omit(data$earliest_cr_line[data$earliest_cr_line <= 8])
old = data$earliest_cr_line[data$earliest_cr_line > 8] %>% as.character(.)
old = paste("19",old)
old = sub(" ","", old) %>% as.numeric(.)
old = 2008 - old
current = as.character(current)
old = as.character(old)
table(current)
table(old)
data$earliest_cr_line = as.numeric(c(current, old))
#This converts last_credit_pull_d to the month of their last credit pull.
data$last_credit_pull_d = sub("-.*", "", data$last_credit_pull_d)
#Gets rid of the percent signs for revol_util and int_rate and converts them to numeric
data$revol_util = as.numeric(sub("%","",data$revol_util))
data$int_rate = as.numeric(sub("%","",data$int_rate))
str(data)
#convert data types
dataQual = data %>% select(c(term,
grade,
sub_grade,
home_ownership,
verification_status,
issue_d,
loan_status,
pymnt_plan,
purpose,
addr_state,
last_credit_pull_d)) %>% mutate_all(factor)
dataQuan = data %>% select(-c(term,
grade,
sub_grade,
home_ownership,
verification_status,
loan_status,
pymnt_plan,
purpose,
addr_state))
str(dataQual)
str(dataQuan)
str(dataQual)
str(dataQuan)
dataQuan = data %>% select(-c(term,
grade,
sub_grade,
home_ownership,
verification_status,
issue_d,
loan_status,
pymnt_plan,
purpose,
addr_state,
last_credit_pull_d))
str(dataQuan)
#final result
table(sapply(cbind(dataQual[1,],dataQuan[1,]),class))
str(dataQual)
str(dataQuan)
str(dataQual)
rm(list=c(current, old))
